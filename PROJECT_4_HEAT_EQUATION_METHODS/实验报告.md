# 项目：热传导方程数值解法比较 - 实验报告

**学生姓名：** [朗昊宇] 

**学号：** [20231050020] 

**完成日期：** [日期2025/6/11]

## 1. 实验目的

本实验旨在通过实现和比较四种不同的数值方法求解一维热传导方程，深入理解偏微分方程数值解法的特点、稳定性和精度问题。

## 2. 理论背景

### 2.1 热传导方程

一维热传导方程的数学形式为：

$$\frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2}$$

其中：
- $u(x,t)$ 是温度分布函数
- $\alpha$ 是热扩散系数
- 边界条件： $u(0,t) = u(L,t) = 0$
- 初始条件： $u(x,0) = f(x)$

### 2.2 数值方法概述

1. **显式差分法（FTCS）**：前向时间，中心空间差分
2. **隐式差分法（BTCS）**：后向时间，中心空间差分
3. **Crank-Nicolson方法**：时间方向二阶精度的隐式方法
4. **solve_ivp方法**：将PDE转化为ODE系统求解

## 3. 算法实现

### 3.1 显式差分法

**核心思想：** 直接从当前时刻的温度分布计算下一时刻的温度分布。使用前向差分近似时间导数，中心差分近似空间二阶导数。

**稳定性条件：** $r = \frac{\alpha \Delta t}{(\Delta x)^2} \leq 0.5$

**关键代码片段：**
```
def solve_explicit(self, dt=0.01, plot_times=None):
    r = self.alpha * dt / (self.dx ** 2)
    if r > 0.5:
        print(f"警告：显式方法稳定性条件不满足 (r={r:.4f} > 0.5)")
    
    u = self.u_initial.copy()
    nt = int(self.T_final / dt) + 1
    
    for n in range(1, nt):
        laplace_u = laplace(u, mode='constant', cval=0.0)
        u += r * laplace_u
        u[0] = 0.0  # 边界条件
        u[-1] = 0.0
```

### 3.2 隐式差分法

**核心思想：** 同时考虑当前和下一时刻的温度分布，通过求解线性方程组得到下一时刻的解。

**优势：** 无条件稳定

**关键代码片段：**
```
def solve_implicit(self, dt=0.1, plot_times=None):
    r = self.alpha * dt / (self.dx ** 2)
    n = self.nx - 2  # 内部节点数
    
    # 构建三对角矩阵
    main_diag = np.ones(n) * (1 + 2 * r)
    lower_diag = np.ones(n - 1) * (-r)
    upper_diag = np.ones(n - 1) * (-r)
    
    A_banded = np.zeros((3, n))
    A_banded[0, 1:] = upper_diag
    A_banded[1, :] = main_diag
    A_banded[2, :-1] = lower_diag
    
    u = self.u_initial.copy()
    
    for n in range(1, nt):
        rhs = u[1:-1].copy()
        u_internal = scipy.linalg.solve_banded((1, 1), A_banded, rhs)
        u[1:-1] = u_internal
        u[0] = 0.0
        u[-1] = 0.0
```

### 3.3 Crank-Nicolson方法

**核心思想：** 在时间上取平均，结合显式和隐式格式，实现时间二阶精度。

**精度：** 时间和空间都是二阶精度

**关键代码片段：**
```
def solve_crank_nicolson(self, dt=0.5, plot_times=None):
    r = self.alpha * dt / (self.dx ** 2)
    n = self.nx - 2
    
    # 构建左端矩阵
    main_diag = np.ones(n) * (1 + r)
    lower_diag = np.ones(n - 1) * (-r/2)
    upper_diag = np.ones(n - 1) * (-r/2)
    
    A_banded = np.zeros((3, n))
    A_banded[0, 1:] = upper_diag
    A_banded[1, :] = main_diag
    A_banded[2, :-1] = lower_diag
    
    u = self.u_initial.copy()
    
    for n in range(1, nt):
        u_internal = u[1:-1]
        rhs = (r/2) * u[:-2] + (1 - r) * u_internal + (r/2) * u[2:]
        u_internal_new = scipy.linalg.solve_banded((1, 1), A_banded, rhs)
        u[1:-1] = u_internal_new
        u[0] = 0.0
        u[-1] = 0.0
```

### 3.4 solve_ivp方法

**核心思想：** 将空间离散化后的热传导方程转化为常微分方程组，使用ODE求解器求解。

**优势：** 自适应步长，高精度

**关键代码片段：**
```
def _heat_equation_ode(self, t, u_internal):
    u_full = np.zeros(self.nx)
    u_full[1:-1] = u_internal
    u_full[0] = 0.0
    u_full[-1] = 0.0
    
    laplace_u = laplace(u_full, mode='constant', cval=0.0)
    d2u_dx2 = laplace_u / (self.dx ** 2)
    return self.alpha * d2u_dx2[1:-1]

def solve_with_solve_ivp(self, method='BDF', plot_times=None):
    u0_internal = self.u_initial[1:-1].copy()
    sol = solve_ivp(
        fun=self._heat_equation_ode,
        t_span=(0, self.T_final),
        y0=u0_internal,
        method=method,
        t_eval=plot_times
    )
    
    solutions = []
    for i in range(sol.y.shape[1]):
        u_full = np.zeros(self.nx)
        u_full[1:-1] = sol.y[:, i]
        solutions.append(u_full)
```

## 4. 实验结果

### 4.1  数值结果

#### 4.1.1 温度分布演化

[![image](https://github.com/user-attachments/assets/a36f5696-2100-48dd-b325-42667c1bf3e8)
]

#### 4.1.2 计算效率比较

| 方法 | 计算时间 (秒) | 时间步数 | 效率评价 |
|------|---------------|----------|----------|
| 显式差分法 | [填入] | [填入] | [评价] |
| 隐式差分法 | [填入] | [填入] | [评价] |
| Crank-Nicolson | [填入] | [填入] | [评价] |
| solve_ivp | [填入] | [填入] | [评价] |

#### 4.2.3 精度分析

以solve_ivp方法作为参考解，计算其他方法的相对误差：

| 方法 | 最大相对误差 | 平均相对误差 | 精度评价 |
|------|--------------|--------------|----------|
| 显式差分法 | [填入] | [填入] | [评价] |
| 隐式差分法 | [填入] | [填入] | [评价] |
| Crank-Nicolson | [填入] | [填入] | [评价] |

### 4.3 稳定性验证

#### 4.3.1 显式方法稳定性

- 稳定性参数： $r =$ [计算值]
- 稳定性判断：[稳定/不稳定]
- 观察现象：[描述数值解的行为]

#### 4.3.2 隐式方法稳定性

- 大时间步长测试： $\Delta t =$ [测试值]
- 稳定性表现：[描述观察结果]

## 5. 结果分析与讨论

### 5.1 方法比较

#### 5.1.1 精度比较

[分析各方法的精度特点，解释精度差异的原因]

#### 5.1.2 效率比较

[分析各方法的计算效率，讨论时间步长限制的影响]

#### 5.1.3 稳定性比较

[比较各方法的稳定性特点，解释稳定性条件的物理意义]

### 5.2 物理现象分析

#### 5.2.1 热扩散过程

[描述温度分布的演化规律，解释物理现象]

#### 5.2.2 边界条件影响

[分析零边界条件对热扩散过程的影响]

### 5.3 数值方法选择建议

根据实验结果，针对不同应用场景提出方法选择建议：

1. **高精度要求**：[推荐方法及理由]
2. **快速计算**：[推荐方法及理由]
3. **长时间模拟**：[推荐方法及理由]
4. **实时应用**：[推荐方法及理由]

## 6. 问题与收获

### 6.1 遇到的主要问题

1. **[问题1]**：[描述问题]
   - 解决方法：[描述解决过程]
   - 经验总结：[总结经验]

2. **[问题2]**：[描述问题]
   - 解决方法：[描述解决过程]
   - 经验总结：[总结经验]

### 6.2 主要收获

1. **理论理解**：[描述对数值方法理论的理解]
2. **编程技能**：[描述编程能力的提升]
3. **科学计算思维**：[描述科学计算思维的培养]
4. **问题解决能力**：[描述问题解决能力的提升]

## 7. 思考题

### 7.1 稳定性分析

为什么显式差分法需要满足稳定性条件 $r \leq 0.5$，而隐式方法无条件稳定？请从数学角度分析。

**答案：** [你的分析]

### 7.2 精度提升

如何进一步提高数值解的精度？请提出至少两种方法并说明原理。

**答案：** [你的建议]

### 7.3 实际应用

在实际工程问题中，如何根据具体需求选择合适的数值方法？

**答案：** [你的思考]

### 7.4 扩展问题

如果要求解二维或三维热传导方程，各种方法的优缺点会如何变化？

**答案：** [你的分析]

## 8. 完整代码

[如果需要，可以在此处附上完整的实现代码]


